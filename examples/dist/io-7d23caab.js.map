{"version":3,"file":"io-7d23caab.js","sources":["../../symbols/src/index.js","../../../node_modules/@babel/runtime/helpers/esm/extends.js","../../is/src/index.js","../../core/src/internal/utils.js","../../core/src/internal/buffers.js","../../core/src/internal/effectTypes.js","../../delay-p/src/index.js","../../core/src/internal/io.js"],"sourcesContent":["const createSymbol = name => `@@redux-saga/${name}`\n\nexport const CANCEL = createSymbol('CANCEL_PROMISE')\nexport const CHANNEL_END_TYPE = createSymbol('CHANNEL_END')\nexport const IO = createSymbol('IO')\nexport const MATCH = createSymbol('MATCH')\nexport const MULTICAST = createSymbol('MULTICAST')\nexport const SAGA_ACTION = createSymbol('SAGA_ACTION')\nexport const SELF_CANCELLATION = createSymbol('SELF_CANCELLATION')\nexport const TASK = createSymbol('TASK')\nexport const TASK_CANCEL = createSymbol('TASK_CANCEL')\nexport const TERMINATE = createSymbol('TERMINATE')\n\nexport const SAGA_LOCATION = createSymbol('LOCATION')\n","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import { TASK, MULTICAST, IO, SAGA_ACTION } from '@redux-saga/symbols'\n\nexport const undef = v => v === null || v === undefined\nexport const notUndef = v => v !== null && v !== undefined\nexport const func = f => typeof f === 'function'\nexport const number = n => typeof n === 'number'\nexport const string = s => typeof s === 'string'\nexport const array = Array.isArray\nexport const object = obj => obj && !array(obj) && typeof obj === 'object'\nexport const promise = p => p && func(p.then)\nexport const iterator = it => it && func(it.next) && func(it.throw)\nexport const iterable = it => (it && func(Symbol) ? func(it[Symbol.iterator]) : array(it))\nexport const task = t => t && t[TASK]\nexport const sagaAction = a => Boolean(a && a[SAGA_ACTION])\nexport const observable = ob => ob && func(ob.subscribe)\nexport const buffer = buf => buf && func(buf.isEmpty) && func(buf.take) && func(buf.put)\nexport const pattern = pat => pat && (string(pat) || symbol(pat) || func(pat) || (array(pat) && pat.every(pattern)))\nexport const channel = ch => ch && func(ch.take) && func(ch.close)\nexport const stringableFunc = f => func(f) && f.hasOwnProperty('toString')\nexport const symbol = sym =>\n  Boolean(sym) && typeof Symbol === 'function' && sym.constructor === Symbol && sym !== Symbol.prototype\nexport const multicast = ch => channel(ch) && ch[MULTICAST]\nexport const effect = eff => eff && eff[IO]\n","import _extends from '@babel/runtime/helpers/extends'\nimport * as is from '@redux-saga/is'\nimport { SAGA_LOCATION, SAGA_ACTION, TASK_CANCEL, TERMINATE } from '@redux-saga/symbols'\n\nexport const konst = v => () => v\nexport const kTrue = konst(true)\nexport const kFalse = konst(false)\n\nlet noop = () => {}\n\nif (process.env.NODE_ENV !== 'production' && typeof Proxy !== 'undefined') {\n  noop = new Proxy(noop, {\n    set: () => {\n      throw internalErr('There was an attempt to assign a property to internal `noop` function.')\n    },\n  })\n}\n\nexport { noop }\n\nexport const identity = v => v\n\nconst hasSymbol = typeof Symbol === 'function'\nexport const asyncIteratorSymbol = hasSymbol && Symbol.asyncIterator ? Symbol.asyncIterator : '@@asyncIterator'\n\nexport function check(value, predicate, error) {\n  if (!predicate(value)) {\n    throw new Error(error)\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport function hasOwn(object, property) {\n  return is.notUndef(object) && hasOwnProperty.call(object, property)\n}\n\nexport const assignWithSymbols = (target, source) => {\n  _extends(target, source)\n\n  if (Object.getOwnPropertySymbols) {\n    Object.getOwnPropertySymbols(source).forEach(s => {\n      target[s] = source[s]\n    })\n  }\n}\n\nexport const flatMap = (mapper, arr) => [].concat(...arr.map(mapper))\n\nexport function remove(array, item) {\n  const index = array.indexOf(item)\n  if (index >= 0) {\n    array.splice(index, 1)\n  }\n}\n\nexport function once(fn) {\n  let called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called = true\n    fn()\n  }\n}\n\nconst kThrow = err => {\n  throw err\n}\nconst kReturn = value => ({ value, done: true })\nexport function makeIterator(next, thro = kThrow, name = 'iterator') {\n  const iterator = { meta: { name }, next, throw: thro, return: kReturn, isSagaIterator: true }\n\n  if (typeof Symbol !== 'undefined') {\n    iterator[Symbol.iterator] = () => iterator\n  }\n  return iterator\n}\n\nexport function logError(error, { sagaStack }) {\n  /*eslint-disable no-console*/\n  console.error(error)\n  console.error(sagaStack)\n}\n\nexport function deprecate(fn, deprecationWarning) {\n  return (...args) => {\n    if (process.env.NODE_ENV !== 'production') console.warn(deprecationWarning)\n    return fn(...args)\n  }\n}\n\nexport const internalErr = err =>\n  new Error(\n    `\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\n  Error: ${err}\n`,\n  )\n\nexport const createSetContextWarning = (ctx, props) =>\n  `${ctx ? ctx + '.' : ''}setContext(props): argument ${props} is not a plain object`\n\nconst FROZEN_ACTION_ERROR = `You can't put (a.k.a. dispatch from saga) frozen actions.\nWe have to define a special non-enumerable property on those actions for scheduling purposes.\nOtherwise you wouldn't be able to communicate properly between sagas & other subscribers (action ordering would become far less predictable).\nIf you are using redux and you care about this behaviour (frozen actions),\nthen you might want to switch to freezing actions in a middleware rather than in action creator.\nExample implementation:\n\nconst freezeActions = store => next => action => next(Object.freeze(action))\n`\n\n// creates empty, but not-holey array\nexport const createEmptyArray = n => Array.apply(null, new Array(n))\n\nexport const wrapSagaDispatch = dispatch => action => {\n  if (process.env.NODE_ENV !== 'production') {\n    check(action, ac => !Object.isFrozen(ac), FROZEN_ACTION_ERROR)\n  }\n  return dispatch(Object.defineProperty(action, SAGA_ACTION, { value: true }))\n}\n\nexport const shouldTerminate = res => res === TERMINATE\nexport const shouldCancel = res => res === TASK_CANCEL\nexport const shouldComplete = res => shouldTerminate(res) || shouldCancel(res)\n\nexport function createAllStyleChildCallbacks(shape, parentCallback) {\n  const keys = Object.keys(shape)\n  const totalCount = keys.length\n\n  if (process.env.NODE_ENV !== 'production') {\n    check(totalCount, c => c > 0, 'createAllStyleChildCallbacks: get an empty array or object')\n  }\n\n  let completedCount = 0\n  let completed\n  const results = is.array(shape) ? createEmptyArray(totalCount) : {}\n  const childCallbacks = {}\n\n  function checkEnd() {\n    if (completedCount === totalCount) {\n      completed = true\n      parentCallback(results)\n    }\n  }\n\n  keys.forEach(key => {\n    const chCbAtKey = (res, isErr) => {\n      if (completed) {\n        return\n      }\n      if (isErr || shouldComplete(res)) {\n        parentCallback.cancel()\n        parentCallback(res, isErr)\n      } else {\n        results[key] = res\n        completedCount++\n        checkEnd()\n      }\n    }\n    chCbAtKey.cancel = noop\n    childCallbacks[key] = chCbAtKey\n  })\n\n  parentCallback.cancel = () => {\n    if (!completed) {\n      completed = true\n      keys.forEach(key => childCallbacks[key].cancel())\n    }\n  }\n\n  return childCallbacks\n}\n\nexport function getMetaInfo(fn) {\n  return {\n    name: fn.name || 'anonymous',\n    location: getLocation(fn),\n  }\n}\n\nexport function getLocation(instrumented) {\n  return instrumented[SAGA_LOCATION]\n}\n","import { kTrue, noop } from './utils'\n\nconst BUFFER_OVERFLOW = \"Channel's Buffer overflow!\"\n\nconst ON_OVERFLOW_THROW = 1\nconst ON_OVERFLOW_DROP = 2\nconst ON_OVERFLOW_SLIDE = 3\nconst ON_OVERFLOW_EXPAND = 4\n\nconst zeroBuffer = { isEmpty: kTrue, put: noop, take: noop }\n\nfunction ringBuffer(limit = 10, overflowAction) {\n  let arr = new Array(limit)\n  let length = 0\n  let pushIndex = 0\n  let popIndex = 0\n\n  const push = it => {\n    arr[pushIndex] = it\n    pushIndex = (pushIndex + 1) % limit\n    length++\n  }\n\n  const take = () => {\n    if (length != 0) {\n      let it = arr[popIndex]\n      arr[popIndex] = null\n      length--\n      popIndex = (popIndex + 1) % limit\n      return it\n    }\n  }\n\n  const flush = () => {\n    let items = []\n    while (length) {\n      items.push(take())\n    }\n    return items\n  }\n\n  return {\n    isEmpty: () => length == 0,\n    put: it => {\n      if (length < limit) {\n        push(it)\n      } else {\n        let doubledLimit\n        switch (overflowAction) {\n          case ON_OVERFLOW_THROW:\n            throw new Error(BUFFER_OVERFLOW)\n          case ON_OVERFLOW_SLIDE:\n            arr[pushIndex] = it\n            pushIndex = (pushIndex + 1) % limit\n            popIndex = pushIndex\n            break\n          case ON_OVERFLOW_EXPAND:\n            doubledLimit = 2 * limit\n\n            arr = flush()\n\n            length = arr.length\n            pushIndex = arr.length\n            popIndex = 0\n\n            arr.length = doubledLimit\n            limit = doubledLimit\n\n            push(it)\n            break\n          default:\n          // DROP\n        }\n      }\n    },\n    take,\n    flush,\n  }\n}\n\nexport const none = () => zeroBuffer\nexport const fixed = limit => ringBuffer(limit, ON_OVERFLOW_THROW)\nexport const dropping = limit => ringBuffer(limit, ON_OVERFLOW_DROP)\nexport const sliding = limit => ringBuffer(limit, ON_OVERFLOW_SLIDE)\nexport const expanding = initialSize => ringBuffer(initialSize, ON_OVERFLOW_EXPAND)\n","export const TAKE = 'TAKE'\nexport const PUT = 'PUT'\nexport const ALL = 'ALL'\nexport const RACE = 'RACE'\nexport const CALL = 'CALL'\nexport const CPS = 'CPS'\nexport const FORK = 'FORK'\nexport const JOIN = 'JOIN'\nexport const CANCEL = 'CANCEL'\nexport const SELECT = 'SELECT'\nexport const ACTION_CHANNEL = 'ACTION_CHANNEL'\nexport const CANCELLED = 'CANCELLED'\nexport const FLUSH = 'FLUSH'\nexport const GET_CONTEXT = 'GET_CONTEXT'\nexport const SET_CONTEXT = 'SET_CONTEXT'\n","import { CANCEL } from '@redux-saga/symbols'\n\nconst MAX_SIGNED_INT = 2147483647\n\nexport default function delayP(ms, val = true) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value\n  if (process.env.NODE_ENV !== 'production' && ms > MAX_SIGNED_INT) {\n    throw new Error('delay only supports a maximum value of ' + MAX_SIGNED_INT + 'ms')\n  }\n  let timeoutId\n  const promise = new Promise(resolve => {\n    timeoutId = setTimeout(resolve, Math.min(MAX_SIGNED_INT, ms), val)\n  })\n\n  promise[CANCEL] = () => {\n    clearTimeout(timeoutId)\n  }\n\n  return promise\n}\n","import delayP from '@redux-saga/delay-p'\nimport * as is from '@redux-saga/is'\nimport { IO, SELF_CANCELLATION } from '@redux-saga/symbols'\nimport { check, createSetContextWarning, identity } from './utils'\nimport * as effectTypes from './effectTypes'\n\nconst TEST_HINT =\n  '\\n(HINT: if you are getting these errors in tests, consider using createMockTask from @redux-saga/testing-utils)'\n\nconst makeEffect = (type, payload) => ({\n  [IO]: true,\n  // this property makes all/race distinguishable in generic manner from other effects\n  // currently it's not used at runtime at all but it's here to satisfy type systems\n  combinator: false,\n  type,\n  payload,\n})\n\nconst isForkEffect = eff => is.effect(eff) && eff.type === effectTypes.FORK\n\nexport const detach = eff => {\n  if (process.env.NODE_ENV !== 'production') {\n    check(eff, isForkEffect, 'detach(eff): argument must be a fork effect')\n  }\n  return makeEffect(effectTypes.FORK, { ...eff.payload, detached: true })\n}\n\nexport function take(patternOrChannel = '*', multicastPattern) {\n  if (process.env.NODE_ENV !== 'production' && arguments.length) {\n    check(arguments[0], is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined')\n  }\n  if (is.pattern(patternOrChannel)) {\n    if (is.notUndef(multicastPattern)) {\n      console.warn(`take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types`)\n    }\n    return makeEffect(effectTypes.TAKE, { pattern: patternOrChannel })\n  }\n  if (is.multicast(patternOrChannel) && is.notUndef(multicastPattern) && is.pattern(multicastPattern)) {\n    return makeEffect(effectTypes.TAKE, { channel: patternOrChannel, pattern: multicastPattern })\n  }\n  if (is.channel(patternOrChannel)) {\n    if (is.notUndef(multicastPattern)) {\n      console.warn(`take(channel) takes one argument but two were provided. Second argument is ignored.`)\n    }\n    return makeEffect(effectTypes.TAKE, { channel: patternOrChannel })\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(`take(patternOrChannel): argument ${patternOrChannel} is not valid channel or a valid pattern`)\n  }\n}\n\nexport const takeMaybe = (...args) => {\n  const eff = take(...args)\n  eff.payload.maybe = true\n  return eff\n}\n\nexport function put(channel, action) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (arguments.length > 1) {\n      check(channel, is.notUndef, 'put(channel, action): argument channel is undefined')\n      check(channel, is.channel, `put(channel, action): argument ${channel} is not a valid channel`)\n      check(action, is.notUndef, 'put(channel, action): argument action is undefined')\n    } else {\n      check(channel, is.notUndef, 'put(action): argument action is undefined')\n    }\n  }\n  if (is.undef(action)) {\n    action = channel\n    // `undefined` instead of `null` to make default parameter work\n    channel = undefined\n  }\n  return makeEffect(effectTypes.PUT, { channel, action })\n}\n\nexport const putResolve = (...args) => {\n  const eff = put(...args)\n  eff.payload.resolve = true\n  return eff\n}\n\nexport function all(effects) {\n  const eff = makeEffect(effectTypes.ALL, effects)\n  eff.combinator = true\n  return eff\n}\n\nexport function race(effects) {\n  const eff = makeEffect(effectTypes.RACE, effects)\n  eff.combinator = true\n  return eff\n}\n\n// this match getFnCallDescriptor logic\nconst validateFnDescriptor = (effectName, fnDescriptor) => {\n  check(fnDescriptor, is.notUndef, `${effectName}: argument fn is undefined or null`)\n\n  if (is.func(fnDescriptor)) {\n    return\n  }\n\n  let context = null\n  let fn\n\n  if (is.array(fnDescriptor)) {\n    ;[context, fn] = fnDescriptor\n    check(fn, is.notUndef, `${effectName}: argument of type [context, fn] has undefined or null \\`fn\\``)\n  } else if (is.object(fnDescriptor)) {\n    ;({ context, fn } = fnDescriptor)\n    check(fn, is.notUndef, `${effectName}: argument of type {context, fn} has undefined or null \\`fn\\``)\n  } else {\n    check(fnDescriptor, is.func, `${effectName}: argument fn is not function`)\n    return\n  }\n\n  if (context && is.string(fn)) {\n    check(context[fn], is.func, `${effectName}: context arguments has no such method - \"${fn}\"`)\n    return\n  }\n\n  check(fn, is.func, `${effectName}: unpacked fn argument (from [context, fn] or {context, fn}) is not a function`)\n}\n\nfunction getFnCallDescriptor(fnDescriptor, args) {\n  let context = null\n  let fn\n\n  if (is.func(fnDescriptor)) {\n    fn = fnDescriptor\n  } else {\n    if (is.array(fnDescriptor)) {\n      ;[context, fn] = fnDescriptor\n    } else {\n      ;({ context, fn } = fnDescriptor)\n    }\n\n    if (context && is.string(fn) && is.func(context[fn])) {\n      fn = context[fn]\n    }\n  }\n\n  return { context, fn, args }\n}\n\nconst isNotDelayEffect = fn => fn !== delay\n\nexport function call(fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    const arg0 = typeof args[0] === 'number' ? args[0] : 'ms'\n    check(\n      fnDescriptor,\n      isNotDelayEffect,\n      `instead of writing \\`yield call(delay, ${arg0})\\` where delay is an effect from \\`redux-saga/effects\\` you should write \\`yield delay(${arg0})\\``,\n    )\n    validateFnDescriptor('call', fnDescriptor)\n  }\n  return makeEffect(effectTypes.CALL, getFnCallDescriptor(fnDescriptor, args))\n}\n\nexport function apply(context, fn, args = []) {\n  const fnDescriptor = [context, fn]\n\n  if (process.env.NODE_ENV !== 'production') {\n    validateFnDescriptor('apply', fnDescriptor)\n  }\n\n  return makeEffect(effectTypes.CALL, getFnCallDescriptor([context, fn], args))\n}\n\nexport function cps(fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateFnDescriptor('cps', fnDescriptor)\n  }\n  return makeEffect(effectTypes.CPS, getFnCallDescriptor(fnDescriptor, args))\n}\n\nexport function fork(fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateFnDescriptor('fork', fnDescriptor)\n\n    check(fnDescriptor, arg => !is.effect(arg), 'fork: argument must not be an effect')\n  }\n  return makeEffect(effectTypes.FORK, getFnCallDescriptor(fnDescriptor, args))\n}\n\nexport function spawn(fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateFnDescriptor('spawn', fnDescriptor)\n  }\n  return detach(fork(fnDescriptor, ...args))\n}\n\nexport function join(taskOrTasks) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (arguments.length > 1) {\n      throw new Error('join(...tasks) is not supported any more. Please use join([...tasks]) to join multiple tasks.')\n    }\n    if (is.array(taskOrTasks)) {\n      taskOrTasks.forEach(t => {\n        check(t, is.task, `join([...tasks]): argument ${t} is not a valid Task object ${TEST_HINT}`)\n      })\n    } else {\n      check(taskOrTasks, is.task, `join(task): argument ${taskOrTasks} is not a valid Task object ${TEST_HINT}`)\n    }\n  }\n\n  return makeEffect(effectTypes.JOIN, taskOrTasks)\n}\n\nexport function cancel(taskOrTasks = SELF_CANCELLATION) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (arguments.length > 1) {\n      throw new Error(\n        'cancel(...tasks) is not supported any more. Please use cancel([...tasks]) to cancel multiple tasks.',\n      )\n    }\n    if (is.array(taskOrTasks)) {\n      taskOrTasks.forEach(t => {\n        check(t, is.task, `cancel([...tasks]): argument ${t} is not a valid Task object ${TEST_HINT}`)\n      })\n    } else if (taskOrTasks !== SELF_CANCELLATION && is.notUndef(taskOrTasks)) {\n      check(taskOrTasks, is.task, `cancel(task): argument ${taskOrTasks} is not a valid Task object ${TEST_HINT}`)\n    }\n  }\n\n  return makeEffect(effectTypes.CANCEL, taskOrTasks)\n}\n\nexport function select(selector = identity, ...args) {\n  if (process.env.NODE_ENV !== 'production' && arguments.length) {\n    check(arguments[0], is.notUndef, 'select(selector, [...]): argument selector is undefined')\n    check(selector, is.func, `select(selector, [...]): argument ${selector} is not a function`)\n  }\n  return makeEffect(effectTypes.SELECT, { selector, args })\n}\n\n/**\n  channel(pattern, [buffer])    => creates a proxy channel for store actions\n**/\nexport function actionChannel(pattern, buffer) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(pattern, is.pattern, 'actionChannel(pattern,...): argument pattern is not valid')\n\n    if (arguments.length > 1) {\n      check(buffer, is.notUndef, 'actionChannel(pattern, buffer): argument buffer is undefined')\n      check(buffer, is.buffer, `actionChannel(pattern, buffer): argument ${buffer} is not a valid buffer`)\n    }\n  }\n\n  return makeEffect(effectTypes.ACTION_CHANNEL, { pattern, buffer })\n}\n\nexport function cancelled() {\n  return makeEffect(effectTypes.CANCELLED, {})\n}\n\nexport function flush(channel) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(channel, is.channel, `flush(channel): argument ${channel} is not valid channel`)\n  }\n\n  return makeEffect(effectTypes.FLUSH, channel)\n}\n\nexport function getContext(prop) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(prop, is.string, `getContext(prop): argument ${prop} is not a string`)\n  }\n\n  return makeEffect(effectTypes.GET_CONTEXT, prop)\n}\n\nexport function setContext(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(props, is.object, createSetContextWarning(null, props))\n  }\n\n  return makeEffect(effectTypes.SET_CONTEXT, props)\n}\n\nexport const delay = call.bind(null, delayP)\n"],"names":["createSymbol","name","CANCEL","CHANNEL_END_TYPE","IO","MATCH","MULTICAST","SAGA_ACTION","SELF_CANCELLATION","TASK","TASK_CANCEL","TERMINATE","SAGA_LOCATION","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","undef","v","notUndef","func","f","string","s","array","Array","isArray","promise","p","then","iterator","it","next","throw","pattern","pat","symbol","every","channel","ch","take","close","stringableFunc","sym","Symbol","constructor","multicast","kTrue","konst","noop","identity","assignWithSymbols","getOwnPropertySymbols","forEach","flatMap","mapper","arr","concat","map","remove","item","index","indexOf","splice","once","fn","called","kThrow","err","kReturn","value","done","makeIterator","thro","meta","return","isSagaIterator","logError","error","sagaStack","console","createEmptyArray","n","wrapSagaDispatch","dispatch","action","defineProperty","shouldTerminate","res","shouldCancel","shouldComplete","createAllStyleChildCallbacks","shape","parentCallback","completed","keys","totalCount","completedCount","results","is","childCallbacks","chCbAtKey","isErr","cancel","getMetaInfo","location","getLocation","instrumented","BUFFER_OVERFLOW","ON_OVERFLOW_THROW","ON_OVERFLOW_SLIDE","ON_OVERFLOW_EXPAND","zeroBuffer","isEmpty","put","ringBuffer","limit","overflowAction","pushIndex","popIndex","push","flush","items","doubledLimit","Error","none","sliding","expanding","initialSize","TAKE","PUT","ALL","RACE","CALL","CPS","FORK","JOIN","SELECT","ACTION_CHANNEL","CANCELLED","FLUSH","GET_CONTEXT","SET_CONTEXT","MAX_SIGNED_INT","delayP","ms","val","timeoutId","Promise","resolve","setTimeout","Math","min","clearTimeout","makeEffect","type","payload","combinator","detach","eff","effectTypes","detached","patternOrChannel","multicastPattern","warn","takeMaybe","maybe","undefined","putResolve","all","effects","race","getFnCallDescriptor","fnDescriptor","args","context","cps","fork","spawn","join","taskOrTasks","select","selector","actionChannel","buffer","cancelled","getContext","prop","setContext","props","delay","bind"],"mappings":"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"}