{"version":3,"file":"redux-saga-effects.umd.min.js","sources":["../../../node_modules/@babel/runtime/helpers/esm/extends.js","../../symbols/src/index.js","../../delay-p/src/index.js","../../is/src/index.js","../../core/src/internal/utils.js","../../core/src/internal/effectTypes.js","../../core/src/internal/io.js","../../core/src/internal/sagaHelpers/fsmIterator.js","../../core/src/internal/sagaHelpers/takeEvery.js","../../core/src/internal/sagaHelpers/takeLatest.js","../../core/src/internal/sagaHelpers/takeLeading.js","../../core/src/internal/buffers.js","../../core/src/internal/sagaHelpers/throttle.js","../../core/src/internal/sagaHelpers/retry.js","../../core/src/internal/sagaHelpers/debounce.js","../../core/src/internal/io-helpers.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","const createSymbol = name => `@@redux-saga/${name}`\n\nexport const CANCEL = createSymbol('CANCEL_PROMISE')\nexport const CHANNEL_END_TYPE = createSymbol('CHANNEL_END')\nexport const IO = createSymbol('IO')\nexport const MATCH = createSymbol('MATCH')\nexport const MULTICAST = createSymbol('MULTICAST')\nexport const SAGA_ACTION = createSymbol('SAGA_ACTION')\nexport const SELF_CANCELLATION = createSymbol('SELF_CANCELLATION')\nexport const TASK = createSymbol('TASK')\nexport const TASK_CANCEL = createSymbol('TASK_CANCEL')\nexport const TERMINATE = createSymbol('TERMINATE')\n\nexport const SAGA_LOCATION = createSymbol('LOCATION')\n","import { CANCEL } from '@redux-saga/symbols'\n\nconst MAX_SIGNED_INT = 2147483647\n\nexport default function delayP(ms, val = true) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value\n  if (process.env.NODE_ENV !== 'production' && ms > MAX_SIGNED_INT) {\n    throw new Error('delay only supports a maximum value of ' + MAX_SIGNED_INT + 'ms')\n  }\n  let timeoutId\n  const promise = new Promise(resolve => {\n    timeoutId = setTimeout(resolve, Math.min(MAX_SIGNED_INT, ms), val)\n  })\n\n  promise[CANCEL] = () => {\n    clearTimeout(timeoutId)\n  }\n\n  return promise\n}\n","import { TASK, MULTICAST, IO, SAGA_ACTION } from '@redux-saga/symbols'\n\nexport const undef = v => v === null || v === undefined\nexport const notUndef = v => v !== null && v !== undefined\nexport const func = f => typeof f === 'function'\nexport const number = n => typeof n === 'number'\nexport const string = s => typeof s === 'string'\nexport const array = Array.isArray\nexport const object = obj => obj && !array(obj) && typeof obj === 'object'\nexport const promise = p => p && func(p.then)\nexport const iterator = it => it && func(it.next) && func(it.throw)\nexport const iterable = it => (it && func(Symbol) ? func(it[Symbol.iterator]) : array(it))\nexport const task = t => t && t[TASK]\nexport const sagaAction = a => Boolean(a && a[SAGA_ACTION])\nexport const observable = ob => ob && func(ob.subscribe)\nexport const buffer = buf => buf && func(buf.isEmpty) && func(buf.take) && func(buf.put)\nexport const pattern = pat => pat && (string(pat) || symbol(pat) || func(pat) || (array(pat) && pat.every(pattern)))\nexport const channel = ch => ch && func(ch.take) && func(ch.close)\nexport const stringableFunc = f => func(f) && f.hasOwnProperty('toString')\nexport const symbol = sym =>\n  Boolean(sym) && typeof Symbol === 'function' && sym.constructor === Symbol && sym !== Symbol.prototype\nexport const multicast = ch => channel(ch) && ch[MULTICAST]\nexport const effect = eff => eff && eff[IO]\n","import _extends from '@babel/runtime/helpers/extends'\nimport * as is from '@redux-saga/is'\nimport { SAGA_LOCATION, SAGA_ACTION, TASK_CANCEL, TERMINATE } from '@redux-saga/symbols'\n\nexport const konst = v => () => v\nexport const kTrue = konst(true)\nexport const kFalse = konst(false)\n\nlet noop = () => {}\n\nif (process.env.NODE_ENV !== 'production' && typeof Proxy !== 'undefined') {\n  noop = new Proxy(noop, {\n    set: () => {\n      throw internalErr('There was an attempt to assign a property to internal `noop` function.')\n    },\n  })\n}\n\nexport { noop }\n\nexport const identity = v => v\n\nconst hasSymbol = typeof Symbol === 'function'\nexport const asyncIteratorSymbol = hasSymbol && Symbol.asyncIterator ? Symbol.asyncIterator : '@@asyncIterator'\n\nexport function check(value, predicate, error) {\n  if (!predicate(value)) {\n    throw new Error(error)\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport function hasOwn(object, property) {\n  return is.notUndef(object) && hasOwnProperty.call(object, property)\n}\n\nexport const assignWithSymbols = (target, source) => {\n  _extends(target, source)\n\n  if (Object.getOwnPropertySymbols) {\n    Object.getOwnPropertySymbols(source).forEach(s => {\n      target[s] = source[s]\n    })\n  }\n}\n\nexport const flatMap = (mapper, arr) => [].concat(...arr.map(mapper))\n\nexport function remove(array, item) {\n  const index = array.indexOf(item)\n  if (index >= 0) {\n    array.splice(index, 1)\n  }\n}\n\nexport function once(fn) {\n  let called = false\n  return () => {\n    if (called) {\n      return\n    }\n    called = true\n    fn()\n  }\n}\n\nconst kThrow = err => {\n  throw err\n}\nconst kReturn = value => ({ value, done: true })\nexport function makeIterator(next, thro = kThrow, name = 'iterator') {\n  const iterator = { meta: { name }, next, throw: thro, return: kReturn, isSagaIterator: true }\n\n  if (typeof Symbol !== 'undefined') {\n    iterator[Symbol.iterator] = () => iterator\n  }\n  return iterator\n}\n\nexport function logError(error, { sagaStack }) {\n  /*eslint-disable no-console*/\n  console.error(error)\n  console.error(sagaStack)\n}\n\nexport function deprecate(fn, deprecationWarning) {\n  return (...args) => {\n    if (process.env.NODE_ENV !== 'production') console.warn(deprecationWarning)\n    return fn(...args)\n  }\n}\n\nexport const internalErr = err =>\n  new Error(\n    `\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project's github repo.\n  Error: ${err}\n`,\n  )\n\nexport const createSetContextWarning = (ctx, props) =>\n  `${ctx ? ctx + '.' : ''}setContext(props): argument ${props} is not a plain object`\n\nconst FROZEN_ACTION_ERROR = `You can't put (a.k.a. dispatch from saga) frozen actions.\nWe have to define a special non-enumerable property on those actions for scheduling purposes.\nOtherwise you wouldn't be able to communicate properly between sagas & other subscribers (action ordering would become far less predictable).\nIf you are using redux and you care about this behaviour (frozen actions),\nthen you might want to switch to freezing actions in a middleware rather than in action creator.\nExample implementation:\n\nconst freezeActions = store => next => action => next(Object.freeze(action))\n`\n\n// creates empty, but not-holey array\nexport const createEmptyArray = n => Array.apply(null, new Array(n))\n\nexport const wrapSagaDispatch = dispatch => action => {\n  if (process.env.NODE_ENV !== 'production') {\n    check(action, ac => !Object.isFrozen(ac), FROZEN_ACTION_ERROR)\n  }\n  return dispatch(Object.defineProperty(action, SAGA_ACTION, { value: true }))\n}\n\nexport const shouldTerminate = res => res === TERMINATE\nexport const shouldCancel = res => res === TASK_CANCEL\nexport const shouldComplete = res => shouldTerminate(res) || shouldCancel(res)\n\nexport function createAllStyleChildCallbacks(shape, parentCallback) {\n  const keys = Object.keys(shape)\n  const totalCount = keys.length\n\n  if (process.env.NODE_ENV !== 'production') {\n    check(totalCount, c => c > 0, 'createAllStyleChildCallbacks: get an empty array or object')\n  }\n\n  let completedCount = 0\n  let completed\n  const results = is.array(shape) ? createEmptyArray(totalCount) : {}\n  const childCallbacks = {}\n\n  function checkEnd() {\n    if (completedCount === totalCount) {\n      completed = true\n      parentCallback(results)\n    }\n  }\n\n  keys.forEach(key => {\n    const chCbAtKey = (res, isErr) => {\n      if (completed) {\n        return\n      }\n      if (isErr || shouldComplete(res)) {\n        parentCallback.cancel()\n        parentCallback(res, isErr)\n      } else {\n        results[key] = res\n        completedCount++\n        checkEnd()\n      }\n    }\n    chCbAtKey.cancel = noop\n    childCallbacks[key] = chCbAtKey\n  })\n\n  parentCallback.cancel = () => {\n    if (!completed) {\n      completed = true\n      keys.forEach(key => childCallbacks[key].cancel())\n    }\n  }\n\n  return childCallbacks\n}\n\nexport function getMetaInfo(fn) {\n  return {\n    name: fn.name || 'anonymous',\n    location: getLocation(fn),\n  }\n}\n\nexport function getLocation(instrumented) {\n  return instrumented[SAGA_LOCATION]\n}\n","export const TAKE = 'TAKE'\nexport const PUT = 'PUT'\nexport const ALL = 'ALL'\nexport const RACE = 'RACE'\nexport const CALL = 'CALL'\nexport const CPS = 'CPS'\nexport const FORK = 'FORK'\nexport const JOIN = 'JOIN'\nexport const CANCEL = 'CANCEL'\nexport const SELECT = 'SELECT'\nexport const ACTION_CHANNEL = 'ACTION_CHANNEL'\nexport const CANCELLED = 'CANCELLED'\nexport const FLUSH = 'FLUSH'\nexport const GET_CONTEXT = 'GET_CONTEXT'\nexport const SET_CONTEXT = 'SET_CONTEXT'\n","import delayP from '@redux-saga/delay-p'\nimport * as is from '@redux-saga/is'\nimport { IO, SELF_CANCELLATION } from '@redux-saga/symbols'\nimport { check, createSetContextWarning, identity } from './utils'\nimport * as effectTypes from './effectTypes'\n\nconst TEST_HINT =\n  '\\n(HINT: if you are getting these errors in tests, consider using createMockTask from @redux-saga/testing-utils)'\n\nconst makeEffect = (type, payload) => ({\n  [IO]: true,\n  // this property makes all/race distinguishable in generic manner from other effects\n  // currently it's not used at runtime at all but it's here to satisfy type systems\n  combinator: false,\n  type,\n  payload,\n})\n\nconst isForkEffect = eff => is.effect(eff) && eff.type === effectTypes.FORK\n\nexport const detach = eff => {\n  if (process.env.NODE_ENV !== 'production') {\n    check(eff, isForkEffect, 'detach(eff): argument must be a fork effect')\n  }\n  return makeEffect(effectTypes.FORK, { ...eff.payload, detached: true })\n}\n\nexport function take(patternOrChannel = '*', multicastPattern) {\n  if (process.env.NODE_ENV !== 'production' && arguments.length) {\n    check(arguments[0], is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined')\n  }\n  if (is.pattern(patternOrChannel)) {\n    if (is.notUndef(multicastPattern)) {\n      console.warn(`take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types`)\n    }\n    return makeEffect(effectTypes.TAKE, { pattern: patternOrChannel })\n  }\n  if (is.multicast(patternOrChannel) && is.notUndef(multicastPattern) && is.pattern(multicastPattern)) {\n    return makeEffect(effectTypes.TAKE, { channel: patternOrChannel, pattern: multicastPattern })\n  }\n  if (is.channel(patternOrChannel)) {\n    if (is.notUndef(multicastPattern)) {\n      console.warn(`take(channel) takes one argument but two were provided. Second argument is ignored.`)\n    }\n    return makeEffect(effectTypes.TAKE, { channel: patternOrChannel })\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(`take(patternOrChannel): argument ${patternOrChannel} is not valid channel or a valid pattern`)\n  }\n}\n\nexport const takeMaybe = (...args) => {\n  const eff = take(...args)\n  eff.payload.maybe = true\n  return eff\n}\n\nexport function put(channel, action) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (arguments.length > 1) {\n      check(channel, is.notUndef, 'put(channel, action): argument channel is undefined')\n      check(channel, is.channel, `put(channel, action): argument ${channel} is not a valid channel`)\n      check(action, is.notUndef, 'put(channel, action): argument action is undefined')\n    } else {\n      check(channel, is.notUndef, 'put(action): argument action is undefined')\n    }\n  }\n  if (is.undef(action)) {\n    action = channel\n    // `undefined` instead of `null` to make default parameter work\n    channel = undefined\n  }\n  return makeEffect(effectTypes.PUT, { channel, action })\n}\n\nexport const putResolve = (...args) => {\n  const eff = put(...args)\n  eff.payload.resolve = true\n  return eff\n}\n\nexport function all(effects) {\n  const eff = makeEffect(effectTypes.ALL, effects)\n  eff.combinator = true\n  return eff\n}\n\nexport function race(effects) {\n  const eff = makeEffect(effectTypes.RACE, effects)\n  eff.combinator = true\n  return eff\n}\n\n// this match getFnCallDescriptor logic\nconst validateFnDescriptor = (effectName, fnDescriptor) => {\n  check(fnDescriptor, is.notUndef, `${effectName}: argument fn is undefined or null`)\n\n  if (is.func(fnDescriptor)) {\n    return\n  }\n\n  let context = null\n  let fn\n\n  if (is.array(fnDescriptor)) {\n    ;[context, fn] = fnDescriptor\n    check(fn, is.notUndef, `${effectName}: argument of type [context, fn] has undefined or null \\`fn\\``)\n  } else if (is.object(fnDescriptor)) {\n    ;({ context, fn } = fnDescriptor)\n    check(fn, is.notUndef, `${effectName}: argument of type {context, fn} has undefined or null \\`fn\\``)\n  } else {\n    check(fnDescriptor, is.func, `${effectName}: argument fn is not function`)\n    return\n  }\n\n  if (context && is.string(fn)) {\n    check(context[fn], is.func, `${effectName}: context arguments has no such method - \"${fn}\"`)\n    return\n  }\n\n  check(fn, is.func, `${effectName}: unpacked fn argument (from [context, fn] or {context, fn}) is not a function`)\n}\n\nfunction getFnCallDescriptor(fnDescriptor, args) {\n  let context = null\n  let fn\n\n  if (is.func(fnDescriptor)) {\n    fn = fnDescriptor\n  } else {\n    if (is.array(fnDescriptor)) {\n      ;[context, fn] = fnDescriptor\n    } else {\n      ;({ context, fn } = fnDescriptor)\n    }\n\n    if (context && is.string(fn) && is.func(context[fn])) {\n      fn = context[fn]\n    }\n  }\n\n  return { context, fn, args }\n}\n\nconst isNotDelayEffect = fn => fn !== delay\n\nexport function call(fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    const arg0 = typeof args[0] === 'number' ? args[0] : 'ms'\n    check(\n      fnDescriptor,\n      isNotDelayEffect,\n      `instead of writing \\`yield call(delay, ${arg0})\\` where delay is an effect from \\`redux-saga/effects\\` you should write \\`yield delay(${arg0})\\``,\n    )\n    validateFnDescriptor('call', fnDescriptor)\n  }\n  return makeEffect(effectTypes.CALL, getFnCallDescriptor(fnDescriptor, args))\n}\n\nexport function apply(context, fn, args = []) {\n  const fnDescriptor = [context, fn]\n\n  if (process.env.NODE_ENV !== 'production') {\n    validateFnDescriptor('apply', fnDescriptor)\n  }\n\n  return makeEffect(effectTypes.CALL, getFnCallDescriptor([context, fn], args))\n}\n\nexport function cps(fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateFnDescriptor('cps', fnDescriptor)\n  }\n  return makeEffect(effectTypes.CPS, getFnCallDescriptor(fnDescriptor, args))\n}\n\nexport function fork(fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateFnDescriptor('fork', fnDescriptor)\n\n    check(fnDescriptor, arg => !is.effect(arg), 'fork: argument must not be an effect')\n  }\n  return makeEffect(effectTypes.FORK, getFnCallDescriptor(fnDescriptor, args))\n}\n\nexport function spawn(fnDescriptor, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateFnDescriptor('spawn', fnDescriptor)\n  }\n  return detach(fork(fnDescriptor, ...args))\n}\n\nexport function join(taskOrTasks) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (arguments.length > 1) {\n      throw new Error('join(...tasks) is not supported any more. Please use join([...tasks]) to join multiple tasks.')\n    }\n    if (is.array(taskOrTasks)) {\n      taskOrTasks.forEach(t => {\n        check(t, is.task, `join([...tasks]): argument ${t} is not a valid Task object ${TEST_HINT}`)\n      })\n    } else {\n      check(taskOrTasks, is.task, `join(task): argument ${taskOrTasks} is not a valid Task object ${TEST_HINT}`)\n    }\n  }\n\n  return makeEffect(effectTypes.JOIN, taskOrTasks)\n}\n\nexport function cancel(taskOrTasks = SELF_CANCELLATION) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (arguments.length > 1) {\n      throw new Error(\n        'cancel(...tasks) is not supported any more. Please use cancel([...tasks]) to cancel multiple tasks.',\n      )\n    }\n    if (is.array(taskOrTasks)) {\n      taskOrTasks.forEach(t => {\n        check(t, is.task, `cancel([...tasks]): argument ${t} is not a valid Task object ${TEST_HINT}`)\n      })\n    } else if (taskOrTasks !== SELF_CANCELLATION && is.notUndef(taskOrTasks)) {\n      check(taskOrTasks, is.task, `cancel(task): argument ${taskOrTasks} is not a valid Task object ${TEST_HINT}`)\n    }\n  }\n\n  return makeEffect(effectTypes.CANCEL, taskOrTasks)\n}\n\nexport function select(selector = identity, ...args) {\n  if (process.env.NODE_ENV !== 'production' && arguments.length) {\n    check(arguments[0], is.notUndef, 'select(selector, [...]): argument selector is undefined')\n    check(selector, is.func, `select(selector, [...]): argument ${selector} is not a function`)\n  }\n  return makeEffect(effectTypes.SELECT, { selector, args })\n}\n\n/**\n  channel(pattern, [buffer])    => creates a proxy channel for store actions\n**/\nexport function actionChannel(pattern, buffer) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(pattern, is.pattern, 'actionChannel(pattern,...): argument pattern is not valid')\n\n    if (arguments.length > 1) {\n      check(buffer, is.notUndef, 'actionChannel(pattern, buffer): argument buffer is undefined')\n      check(buffer, is.buffer, `actionChannel(pattern, buffer): argument ${buffer} is not a valid buffer`)\n    }\n  }\n\n  return makeEffect(effectTypes.ACTION_CHANNEL, { pattern, buffer })\n}\n\nexport function cancelled() {\n  return makeEffect(effectTypes.CANCELLED, {})\n}\n\nexport function flush(channel) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(channel, is.channel, `flush(channel): argument ${channel} is not valid channel`)\n  }\n\n  return makeEffect(effectTypes.FLUSH, channel)\n}\n\nexport function getContext(prop) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(prop, is.string, `getContext(prop): argument ${prop} is not a string`)\n  }\n\n  return makeEffect(effectTypes.GET_CONTEXT, prop)\n}\n\nexport function setContext(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(props, is.object, createSetContextWarning(null, props))\n  }\n\n  return makeEffect(effectTypes.SET_CONTEXT, props)\n}\n\nexport const delay = call.bind(null, delayP)\n","import * as is from '@redux-saga/is'\nimport { makeIterator } from '../utils'\n\nconst done = value => ({ done: true, value })\nexport const qEnd = {}\n\nexport function safeName(patternOrChannel) {\n  if (is.channel(patternOrChannel)) {\n    return 'channel'\n  }\n\n  if (is.stringableFunc(patternOrChannel)) {\n    return String(patternOrChannel)\n  }\n\n  if (is.func(patternOrChannel)) {\n    return patternOrChannel.name\n  }\n\n  return String(patternOrChannel)\n}\n\nexport default function fsmIterator(fsm, startState, name) {\n  let stateUpdater,\n    errorState,\n    effect,\n    nextState = startState\n\n  function next(arg, error) {\n    if (nextState === qEnd) {\n      return done(arg)\n    }\n    if (error && !errorState) {\n      nextState = qEnd\n      throw error\n    } else {\n      stateUpdater && stateUpdater(arg)\n      const currentState = error ? fsm[errorState](error) : fsm[nextState]()\n      ;({ nextState, effect, stateUpdater, errorState } = currentState)\n      return nextState === qEnd ? done(arg) : effect\n    }\n  }\n\n  return makeIterator(next, error => next(null, error), name)\n}\n","import fsmIterator, { safeName } from './fsmIterator'\nimport { take, fork } from '../io'\n\nexport default function takeEvery(patternOrChannel, worker, ...args) {\n  const yTake = { done: false, value: take(patternOrChannel) }\n  const yFork = ac => ({ done: false, value: fork(worker, ...args, ac) })\n\n  let action,\n    setAction = ac => (action = ac)\n\n  return fsmIterator(\n    {\n      q1() {\n        return { nextState: 'q2', effect: yTake, stateUpdater: setAction }\n      },\n      q2() {\n        return { nextState: 'q1', effect: yFork(action) }\n      },\n    },\n    'q1',\n    `takeEvery(${safeName(patternOrChannel)}, ${worker.name})`,\n  )\n}\n","import fsmIterator, { safeName } from './fsmIterator'\nimport { cancel, take, fork } from '../io'\n\nexport default function takeLatest(patternOrChannel, worker, ...args) {\n  const yTake = { done: false, value: take(patternOrChannel) }\n  const yFork = ac => ({ done: false, value: fork(worker, ...args, ac) })\n  const yCancel = task => ({ done: false, value: cancel(task) })\n\n  let task, action\n  const setTask = t => (task = t)\n  const setAction = ac => (action = ac)\n\n  return fsmIterator(\n    {\n      q1() {\n        return { nextState: 'q2', effect: yTake, stateUpdater: setAction }\n      },\n      q2() {\n        return task\n          ? { nextState: 'q3', effect: yCancel(task) }\n          : { nextState: 'q1', effect: yFork(action), stateUpdater: setTask }\n      },\n      q3() {\n        return { nextState: 'q1', effect: yFork(action), stateUpdater: setTask }\n      },\n    },\n    'q1',\n    `takeLatest(${safeName(patternOrChannel)}, ${worker.name})`,\n  )\n}\n","import fsmIterator, { safeName } from './fsmIterator'\nimport { take, call } from '../io'\n\nexport default function takeLeading(patternOrChannel, worker, ...args) {\n  const yTake = { done: false, value: take(patternOrChannel) }\n  const yCall = ac => ({ done: false, value: call(worker, ...args, ac) })\n\n  let action\n  const setAction = ac => (action = ac)\n\n  return fsmIterator(\n    {\n      q1() {\n        return { nextState: 'q2', effect: yTake, stateUpdater: setAction }\n      },\n      q2() {\n        return { nextState: 'q1', effect: yCall(action) }\n      },\n    },\n    'q1',\n    `takeLeading(${safeName(patternOrChannel)}, ${worker.name})`,\n  )\n}\n","import { kTrue, noop } from './utils'\n\nconst BUFFER_OVERFLOW = \"Channel's Buffer overflow!\"\n\nconst ON_OVERFLOW_THROW = 1\nconst ON_OVERFLOW_DROP = 2\nconst ON_OVERFLOW_SLIDE = 3\nconst ON_OVERFLOW_EXPAND = 4\n\nconst zeroBuffer = { isEmpty: kTrue, put: noop, take: noop }\n\nfunction ringBuffer(limit = 10, overflowAction) {\n  let arr = new Array(limit)\n  let length = 0\n  let pushIndex = 0\n  let popIndex = 0\n\n  const push = it => {\n    arr[pushIndex] = it\n    pushIndex = (pushIndex + 1) % limit\n    length++\n  }\n\n  const take = () => {\n    if (length != 0) {\n      let it = arr[popIndex]\n      arr[popIndex] = null\n      length--\n      popIndex = (popIndex + 1) % limit\n      return it\n    }\n  }\n\n  const flush = () => {\n    let items = []\n    while (length) {\n      items.push(take())\n    }\n    return items\n  }\n\n  return {\n    isEmpty: () => length == 0,\n    put: it => {\n      if (length < limit) {\n        push(it)\n      } else {\n        let doubledLimit\n        switch (overflowAction) {\n          case ON_OVERFLOW_THROW:\n            throw new Error(BUFFER_OVERFLOW)\n          case ON_OVERFLOW_SLIDE:\n            arr[pushIndex] = it\n            pushIndex = (pushIndex + 1) % limit\n            popIndex = pushIndex\n            break\n          case ON_OVERFLOW_EXPAND:\n            doubledLimit = 2 * limit\n\n            arr = flush()\n\n            length = arr.length\n            pushIndex = arr.length\n            popIndex = 0\n\n            arr.length = doubledLimit\n            limit = doubledLimit\n\n            push(it)\n            break\n          default:\n          // DROP\n        }\n      }\n    },\n    take,\n    flush,\n  }\n}\n\nexport const none = () => zeroBuffer\nexport const fixed = limit => ringBuffer(limit, ON_OVERFLOW_THROW)\nexport const dropping = limit => ringBuffer(limit, ON_OVERFLOW_DROP)\nexport const sliding = limit => ringBuffer(limit, ON_OVERFLOW_SLIDE)\nexport const expanding = initialSize => ringBuffer(initialSize, ON_OVERFLOW_EXPAND)\n","import fsmIterator, { safeName } from './fsmIterator'\nimport { take, fork, actionChannel, delay } from '../io'\nimport * as buffers from '../buffers'\n\nexport default function throttle(delayLength, pattern, worker, ...args) {\n  let action, channel\n\n  const yActionChannel = { done: false, value: actionChannel(pattern, buffers.sliding(1)) }\n  const yTake = () => ({ done: false, value: take(channel) })\n  const yFork = ac => ({ done: false, value: fork(worker, ...args, ac) })\n  const yDelay = { done: false, value: delay(delayLength) }\n\n  const setAction = ac => (action = ac)\n  const setChannel = ch => (channel = ch)\n\n  return fsmIterator(\n    {\n      q1() {\n        return { nextState: 'q2', effect: yActionChannel, stateUpdater: setChannel }\n      },\n      q2() {\n        return { nextState: 'q3', effect: yTake(), stateUpdater: setAction }\n      },\n      q3() {\n        return { nextState: 'q4', effect: yFork(action) }\n      },\n      q4() {\n        return { nextState: 'q2', effect: yDelay }\n      },\n    },\n    'q1',\n    `throttle(${safeName(pattern)}, ${worker.name})`,\n  )\n}\n","import fsmIterator, { qEnd } from './fsmIterator'\nimport { call, delay } from '../io'\n\nexport default function retry(maxTries, delayLength, fn, ...args) {\n  let counter = maxTries\n\n  const yCall = { done: false, value: call(fn, ...args) }\n  const yDelay = { done: false, value: delay(delayLength) }\n\n  return fsmIterator(\n    {\n      q1() {\n        return {nextState: 'q2', effect: yCall, errorState: 'q10'}\n      },\n      q2() {\n        return {nextState: qEnd}\n      },\n      q10 (error) {\n        counter -= 1\n        if (counter <= 0) {\n          throw error\n        }\n        return {nextState: 'q1', effect: yDelay}\n      },\n    },\n    'q1',\n    `retry(${fn.name})`,\n  )\n}\n","import fsmIterator, { safeName } from './fsmIterator'\nimport { delay, fork, race, take } from '../io'\n\nexport default function debounceHelper(delayLength, patternOrChannel, worker, ...args) {\n  let action, raceOutput\n\n  const yTake = { done: false, value: take(patternOrChannel) }\n  const yRace = {\n    done: false,\n    value: race({\n      action: take(patternOrChannel),\n      debounce: delay(delayLength),\n    }),\n  }\n  const yFork = ac => ({ done: false, value: fork(worker, ...args, ac) })\n  const yNoop = value => ({ done: false, value })\n\n  const setAction = ac => (action = ac)\n  const setRaceOutput = ro => (raceOutput = ro)\n\n  return fsmIterator(\n    {\n      q1() {\n        return { nextState: 'q2', effect: yTake, stateUpdater: setAction }\n      },\n      q2() {\n        return { nextState: 'q3', effect: yRace, stateUpdater: setRaceOutput }\n      },\n      q3() {\n        return raceOutput.debounce\n          ? { nextState: 'q1', effect: yFork(action) }\n          : { nextState: 'q2', effect: yNoop(raceOutput.action), stateUpdater: setAction }\n      },\n    },\n    'q1',\n    `debounce(${safeName(patternOrChannel)}, ${worker.name})`,\n  )\n}\n","import * as is from '@redux-saga/is'\nimport { call, fork } from './io'\nimport { check } from './utils'\nimport {\n  takeEveryHelper,\n  takeLatestHelper,\n  takeLeadingHelper,\n  throttleHelper,\n  retryHelper,\n  debounceHelper,\n} from './sagaHelpers'\n\nconst validateTakeEffect = (fn, patternOrChannel, worker) => {\n  check(patternOrChannel, is.notUndef, `${fn.name} requires a pattern or channel`)\n  check(worker, is.notUndef, `${fn.name} requires a saga parameter`)\n}\n\nexport function takeEvery(patternOrChannel, worker, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateTakeEffect(takeEvery, patternOrChannel, worker)\n  }\n\n  return fork(takeEveryHelper, patternOrChannel, worker, ...args)\n}\n\nexport function takeLatest(patternOrChannel, worker, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateTakeEffect(takeLatest, patternOrChannel, worker)\n  }\n\n  return fork(takeLatestHelper, patternOrChannel, worker, ...args)\n}\n\nexport function takeLeading(patternOrChannel, worker, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateTakeEffect(takeLeading, patternOrChannel, worker)\n  }\n\n  return fork(takeLeadingHelper, patternOrChannel, worker, ...args)\n}\n\nexport function throttle(ms, pattern, worker, ...args) {\n  if (process.env.NODE_ENV !== 'production') {\n    check(pattern, is.notUndef, 'throttle requires a pattern')\n    check(worker, is.notUndef, 'throttle requires a saga parameter')\n  }\n\n  return fork(throttleHelper, ms, pattern, worker, ...args)\n}\n\nexport function retry(maxTries, delayLength, worker, ...args) {\n  return call(retryHelper, maxTries, delayLength, worker, ...args)\n}\n\nexport function debounce(delayLength, pattern, worker, ...args) {\n  return fork(debounceHelper, delayLength, pattern, worker, ...args)\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","createSymbol","name","CANCEL","IO","MULTICAST","SELF_CANCELLATION","MAX_SIGNED_INT","delayP","ms","val","timeoutId","promise","Promise","resolve","setTimeout","Math","min","clearTimeout","undef","v","notUndef","func","f","string","s","array","Array","isArray","pattern","pat","symbol","every","channel","ch","take","close","stringableFunc","sym","Symbol","constructor","multicast","identity","kThrow","err","kReturn","value","done","TAKE","PUT","ALL","RACE","CALL","CPS","FORK","JOIN","SELECT","ACTION_CHANNEL","CANCELLED","FLUSH","GET_CONTEXT","SET_CONTEXT","makeEffect","type","payload","combinator","detach","eff","effectTypes","detached","patternOrChannel","multicastPattern","is","console","warn","put","action","undefined","race","effects","getFnCallDescriptor","fnDescriptor","args","fn","context","fork","cancel","taskOrTasks","actionChannel","buffer","delay","bind","qEnd","safeName","String","fsmIterator","fsm","startState","stateUpdater","errorState","effect","nextState","next","arg","error","currentState","thro","iterator","meta","throw","return","isSagaIterator","makeIterator","takeEvery","worker","yTake","setAction","ac","q1","q2","takeLatest","task","yFork","yCancel","setTask","t","q3","takeLeading","BUFFER_OVERFLOW","ON_OVERFLOW_THROW","ON_OVERFLOW_SLIDE","ON_OVERFLOW_EXPAND","sliding","limit","overflowAction","arr","pushIndex","popIndex","push","it","flush","items","isEmpty","doubledLimit","Error","ringBuffer","throttle","delayLength","yActionChannel","buffers","yDelay","setChannel","q4","retry","maxTries","counter","yCall","q10","debounceHelper","raceOutput","yRace","debounce","setRaceOutput","ro","prop","retryHelper","selector","props","takeEveryHelper","takeLatestHelper","takeLeadingHelper","maybe","throttleHelper"],"mappings":"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"}